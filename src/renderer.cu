#include <assert.h>
#include <stdio.h>
#include <time.h>

#include <iostream>

#include "bsdf.h"
#include "headers.h"
#include "lst.h"
#include "mathops.h"
#include "random.h"
#include "renderer.h"
#include "scene.h"

struct context_t {
    const __restrict__ scene_t *scene;
    const __restrict__ bvh_t *bvh;
    const __restrict__ lst_t *lst;
    const config_t cfg;
    rand_state_t rstate;

    PLATFORM context_t(const scene_t *_scene, const bvh_t *_bvh, const lst_t *_lst,
                       config_t _cfg)
        : scene(_scene), bvh(_bvh), lst(_lst), cfg(_cfg) {
    }
};

static PLATFORM void get_camera_ray(Ray &ray, const __restrict__ scene_t *scene, float u,
                                    float v) {
    const Vec3 &P = scene->camera.position;
    const Vec3 &T = scene->camera.target;
    const Vec3 &Up = scene->camera.updir;

    Vec3 W = T - P;
    Vec3 U = W.cross(Up);
    Vec3 V = U.cross(W);

    float focal_length = 0.1; // doesn't really matter at this point
    float yheight = atanf(0.5 * scene->camera.yfov) * focal_length;

    U = U.normalized() * yheight;
    V = V.normalized() * yheight;
    W = W.normalized() * focal_length;

    // U, V, W build orthogonal basis for camera ray direction
    // D = u*U + v*V + 1*W
    // build change of basis matrix A
    Mat3 A(U.x, V.x, W.x, U.y, V.y, W.y, U.z, V.z, W.z);

    // camera coordinate vector for pixel
    Vec3 x = {u, v, 1};

    ray.o = P;
    ray.r = (A * x).normalized();
}

// offset new ray slightly from triangle in normal dir
#define SAVE_RAY_EPS 1e-6

static PLATFORM void initialize_safe_ray(Ray &ray, const Vec3 &origin, const Vec3 &dir,
                                         const Vec3 &normal) {
    bool transmit = dir.dot(normal) < 0;

    ray.o = origin + SAVE_RAY_EPS * (transmit ? -normal : normal);
    ray.r = dir;
}

static PLATFORM void intersect(const __restrict__ bvh_t *bvh, const __restrict__ scene_t *scene,
                               const Ray &ray, intersection_t &hit) {
#ifdef USE_INTERSECT_CRUDE
    intersect_crude(scene, ray, hit);
#else
    bvh_intersect_iterative(bvh, scene, ray, hit);
#endif
}

// generated by gpt may not work
static PLATFORM Vec3 sample_triangle_uniform(rand_state_t &rstate, const Vec3 &a, const Vec3 &b,
                                             const Vec3 &c) {
    float u1, u2;
    do {
        u1 = random_uniform(rstate);
        u2 = random_uniform(rstate);
    } while (u1 + u2 > 1);
    return a + u1 * (b - a) + u2 * (c - a);
}

// static PLATFORM float
// area_of_triangle(const Vec3& a, const Vec3& b, const Vec3& c) {
//     Vec3 n = (c - b).cross(a - b);
//     return 0.5 * n.magnitude();
// }

struct area_light_sample_t {
    Vec3 normal, dir;
    bool visible;
    float distance, area;
    float p;
};
static PLATFORM void sample_area_light(area_light_sample_t &out, context_t &c,
                                       const Vec3 &shadow_pos, const Vec3 &shadow_normal,
                                       int face_index, bool direction_given) {
    const face_t &face = c.scene->faces[face_index];
    const material_t &mat = c.scene->materials[face.material];
    assert(face.vertexCount == 3);

    const Vec3 &A = c.scene->vertices[face.vertices[0]].position;
    const Vec3 &B = c.scene->vertices[face.vertices[1]].position;
    const Vec3 &C = c.scene->vertices[face.vertices[2]].position;

    Vec3 tri_cross = (C - B).cross(A - B);
    float tri_cross_length = tri_cross.magnitude();
    out.normal = tri_cross / tri_cross_length;
    out.area = 0.5 * tri_cross_length;

    if (!direction_given) {
        Vec3 light_pos = sample_triangle_uniform(c.rstate, A, B, C);
        out.dir = (light_pos - shadow_pos).normalized();
    }

    Ray shadow_ray;
    initialize_safe_ray(shadow_ray, shadow_pos, out.dir, shadow_normal);

    // check visibility
    intersection_t light_hit;
    intersect(c.bvh, c.scene, shadow_ray, light_hit);
    out.visible = light_hit.faceIndex == face_index;

    // check if light points towards face
    intersection_t pdf_hit;
    intersect_face(c.scene, shadow_ray, pdf_hit, face_index);

    out.distance = pdf_hit.distance;
    if (pdf_hit.has_hit) {
        float cosThetaY = std::abs(out.normal.dot(out.dir));
        out.p = out.distance * out.distance / (out.area * cosThetaY);
    } else {
        out.p = 0;
    }
}

struct light_source_sample_t {
    Vec3 Ld;
    float p_direct;
    bool visible;
    Vec3 light_dir;
    bsdf_sample_t light_dir_bsdf;
};

static PLATFORM void sample_light_source(light_source_sample_t &out, context_t &c,
                                         const Ray &ray, const intersection_t &hit) {
    if (c.lst->nodes.count == 0) {
        out.p_direct = 0;
        return;
    }

    // pick light node uniformly random
    int nodeIndex = (int)(c.lst->nodes.count * random_uniform(c.rstate));
    const lst_node_t &node = c.lst->nodes[nodeIndex % c.lst->nodes.count];

    out.p_direct = 1.0f / (float)c.lst->nodes.count;

    if (node.type == LST_SOURCE_LIGHT) {
        const light_t &light = c.scene->lights[0];

        if (light.type == LIGHT_POINT) {
            float light_rad = 0.1;
            Vec3 light_pos = light.position + light_rad * sphere_sample_uniform(c.rstate);

            Vec3 hit_to_light = light_pos - hit.position;
            float r = hit_to_light.magnitude();
            out.light_dir = hit_to_light / r;

            Ray shadow_ray;
            initialize_safe_ray(shadow_ray, hit.position, out.light_dir, hit.trueNormal);

            intersection_t light_hit;
            intersect(c.bvh, c.scene, shadow_ray, light_hit);
            out.visible = r < light_hit.distance;
            if (!out.visible) {
                out.p_direct = 0;
                return;
            }

            // diffuse
            evaluate_bsdf(out.light_dir_bsdf, ray.r, out.light_dir, hit, c.rstate);

            float cosThetaX = std::abs(hit.trueNormal.dot(out.light_dir));

            float radiantIntensity =
                light.intensity /
                683.0; // this is only approximation, color spaces are violated
            Vec3 integrand = light.color * radiantIntensity / (r * r);

            out.Ld = out.light_dir_bsdf.bsdf * integrand * cosThetaX; // *integrates* over point

            // probability stays same because point light is dirac delta function

        } else {
            // directional light:
            assert(false); // TODO
            out.p_direct = 0;
        }

    } else {
        // emitting face:

        area_light_sample_t la;
        sample_area_light(la, c, hit.position, hit.trueNormal, node.index, false);

        out.light_dir = la.dir;

        evaluate_bsdf(out.light_dir_bsdf, ray.r, out.light_dir, hit, c.rstate);
        // printf("%.2f\n", out.light_dir_bsdf.prob_i);

        const face_t &face = c.scene->faces[node.index];
        const material_t &mat = c.scene->materials[face.material];
        Vec3 radiosity = mat.emissive;

        float cosThetaX = std::abs(hit.trueNormal.dot(out.light_dir));

        out.p_direct = la.p;
        out.visible = la.visible;

        if (la.visible) {
            out.Ld = out.light_dir_bsdf.bsdf * radiosity * cosThetaX;

        } else {
            out.Ld = Vec3::Zero();
        }
    }
}

static PLATFORM float evaluate_direct_p(context_t &c, const Ray &ray,
                                        const intersection_t &hit) {
    float p_total = 0;

    for (int i = 0; i < c.lst->nodes.count; i++) {
        float p_node;

        const lst_node_t &node = c.lst->nodes[i];

        if (node.type == LST_SOURCE_LIGHT) {
            p_node = 0;

        } else {
            // face
            area_light_sample_t la;
            la.dir = ray.r;
            sample_area_light(la, c, hit.position, hit.trueNormal, node.index, true);
            p_node = la.p;
        }

        p_total += p_node;
    }

    p_total /= (float)c.lst->nodes.count;
    return p_total;
}

#define RR_PROB_MAX 0.99

static PLATFORM Vec3 integrate_Li(context_t &c, Ray ray) {
    Vec3 light = {0, 0, 0};
    Vec3 throughput = {1, 1, 1};

    for (int depth = 0;; depth++) {
        intersection_t hit;
        intersect(c.bvh, c.scene, ray, hit);
        if (!hit.has_hit) {
            light += throughput * c.cfg.world_clear_color;
            break;
        }

        // direct light, attenuate using throughput which includes indirect lighting penalty
        Vec3 Le = hit.mat->emissive * throughput;
        light += Le;

        float rr_prob = fminf(throughput.maxComponent(), RR_PROB_MAX);
        if (random_uniform(c.rstate) >= rr_prob) {
            break; // ray dies
        }

        light_source_sample_t lss;
        sample_light_source(lss, c, ray, hit);

        if (lss.visible && lss.p_direct > 0) {
            // balance heuristic on part of direct light
            float weight = lss.p_direct / (lss.p_direct + lss.light_dir_bsdf.prob_i);
            // printf("%.2f, %.2f\n", lss.p_direct, lss.light_dir_bsdf.prob_i);
            light += throughput * (weight * lss.Ld / lss.p_direct);
        }

        bsdf_sample_t bsdf;
        sample_bsdf(bsdf, ray.r, hit, c.rstate);
        assert(bsdf.prob_i != 0 && "sample with 0 probability");

        // set next ray
        initialize_safe_ray(ray, hit.position, bsdf.omega_i, hit.trueNormal);

        float p_direct = evaluate_direct_p(c, ray, hit);
        float weight = bsdf.prob_i / (p_direct + bsdf.prob_i);

        float cosTheta = std::abs(hit.trueNormal.dot(bsdf.omega_i));

        // find next throughput
        throughput *= bsdf.bsdf * (weight * cosTheta / (bsdf.prob_i * rr_prob));
    }

    return light;
}

#ifdef USE_CPU_RENDER

__host__ void render_host(Vec3 *img, const __restrict__ bvh_t *bvh,
                          const __restrict__ obj_scene_data *scene, int pixel_x, int pixel_y,
                          settings_t settings, int previous_samples) {
    uint64_t tid = pixel_y * settings.width + pixel_x;

    rand_state_t rstate;
    random_init(rstate, settings.seed, tid);

    Vec3 total_light = {0, 0, 0};

    for (int i = 0; i < settings.samples; i++) {
        // float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x; /* TODO sensor variance */
        float sensor_y = (float)pixel_y; /* TODO sensor variance */

        float u = (2 * sensor_x - settings.width) / (float)settings.height;
        float v = (2 * sensor_y - settings.height) / (float)settings.height;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v, settings);

        Vec3 current_light = integrate_Li_iterative(bvh, scene, camera_ray, rstate);
        total_light += current_light;
    }

    total_light /= (float)settings.samples_per_round;

    int total_samples = settings.samples_per_round + previous_samples;
    Vec3 &pixel = img[pixel_y * settings.width + pixel_x];

    pixel = pixel * (previous_samples / (float)total_samples) +
            total_light * (settings.samples_per_round / (float)total_samples);
}

#else

// static PLATFORM Vec3
// sphere_sample_uniform(rand_state_t& rstate) {
//     Vec3 r;
//     do {
//         r.x = 2 * random_uniform(rstate) - 1;
//         r.y = 2 * random_uniform(rstate) - 1;
//         r.z = 2 * random_uniform(rstate) - 1;
//     } while (r.dot(r) > 1);

//     return r.normalized();
// }

// static PLATFORM void
// sanity_check(context_t& c) {

//     float a = 3;
//     Vec3 p;
//     p.x = 2 * a * random_uniform(c.rstate) - a;
//     p.y = 2 * a * random_uniform(c.rstate) - a;
//     p.z = 2 * a * random_uniform(c.rstate) - a;

//     intersection_t test_hit = {
//         has_hit: true,
//         distance: 0,
//         position: p,
//         lightingNormal: Vec3(1, 0, 0),
//         trueNormal: Vec3(1, 0, 0),
//         faceIndex: -1,
//         mat: nullptr,
//     };

//     int N = 100000;
//     float prob = 0;

//     for (int i = 0; i < N; i++) {

//         Vec3 r = sphere_sample_uniform(c.rstate);

//         Ray ray = { o: p, r: r };

//         prob += evaluate_direct_p(c, ray, test_hit);
//     }

//     printf("sum of p = %f\n", 4 * 3.1415 * prob / N);
// }

__global__ void render_kernel(Vec3 *img, const __restrict__ bvh_t *bvh,
                              const __restrict__ scene_t *scene, const __restrict__ lst_t *lst,
                              config_t cfg, int previousSamples, int currentSamples) {
    int pixel_x = threadIdx.x + blockDim.x * blockIdx.x;
    int pixel_y = threadIdx.y + blockDim.y * blockIdx.y;

    if (pixel_x >= cfg.resolution_x || pixel_y >= cfg.resolution_y) {
        return; // out of image
    }

    uint64_t curand_tid = pixel_y * cfg.resolution_x + pixel_x;

    context_t c(scene, bvh, lst, cfg);

    random_init(c.rstate, cfg.seed, curand_tid);

    Vec3 total_light = {0, 0, 0};

    // sanity_check(c);
    // return;

    for (int i = 0; i < currentSamples; i++) {
        float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x + sensor_variance * random_normal(c.rstate);
        float sensor_y = (float)pixel_y + sensor_variance * random_normal(c.rstate);

        float u = (2 * sensor_x - cfg.resolution_x) / (float)cfg.resolution_y;
        float v = (2 * sensor_y - cfg.resolution_y) / (float)cfg.resolution_y;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v);

        Vec3 current_light = integrate_Li(c, camera_ray);
        // Vec3 current_light = integrate_Li_classic(bvh, scene, lst, camera_ray, rstate,
        // settings);

        total_light += current_light;
    }

    total_light *= 2; // test exposure

    total_light /= (float)currentSamples;

    int total_samples = previousSamples + currentSamples;
    Vec3 last_pixel = img[pixel_y * cfg.resolution_x + pixel_x];

    Vec3 next_pixel = last_pixel * (previousSamples / (float)total_samples) +
                      total_light * (currentSamples / (float)total_samples);

    img[pixel_y * cfg.resolution_x + pixel_x] = next_pixel;
}

#endif
