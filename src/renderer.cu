#include <assert.h>
#include <stdio.h>
#include <time.h>

#include <iostream>

#include "bsdf.h"
#include "headers.h"
#include "lst.h"
#include "mathops.h"
#include "random.h"
#include "renderer.h"
#include "scene.h"

struct context_t {
    const __restrict__ scene_t *scene;
    const __restrict__ bvh_t *bvh;
    const __restrict__ lst_t *lst;
    const config_t cfg;
    rand_state_t rstate;

    PLATFORM context_t(const scene_t *_scene, const bvh_t *_bvh, const lst_t *_lst,
                       config_t _cfg)
        : scene(_scene), bvh(_bvh), lst(_lst), cfg(_cfg) {
    }
};

static PLATFORM void get_camera_ray(Ray &ray, const __restrict__ scene_t *scene, float u,
                                    float v) {
    const Vec3 &P = scene->camera.position;
    const Vec3 &T = scene->camera.target;
    const Vec3 &Up = scene->camera.updir;

    Vec3 W = T - P;
    Vec3 U = W.cross(Up);
    Vec3 V = U.cross(W);

    float focal_length = 0.1; // doesn't really matter at this point
    float yheight = atanf(0.5 * scene->camera.yfov) * focal_length;

    U = U.normalized() * yheight;
    V = V.normalized() * yheight;
    W = W.normalized() * focal_length;

    // U, V, W build orthogonal basis for camera ray direction
    // D = u*U + v*V + 1*W
    // build change of basis matrix A
    Mat3 A(U.x, V.x, W.x, U.y, V.y, W.y, U.z, V.z, W.z);

    // camera coordinate vector for pixel
    Vec3 x = {u, v, 1};

    ray.o = P;
    ray.r = (A * x).normalized();
}

// offset new ray slightly from triangle in normal dir
#define SAVE_RAY_EPS 1e-6

static PLATFORM void initialize_safe_ray(Ray &ray, const Vec3 &origin, const Vec3 &dir,
                                         const Vec3 &normal) {
    bool transmit = dir.dot(normal) < 0;

    ray.o = origin + SAVE_RAY_EPS * (transmit ? -normal : normal);
    ray.r = dir;
}

static PLATFORM void intersect(const __restrict__ bvh_t *bvh, const __restrict__ scene_t *scene,
                               const Ray &ray, intersection_t &hit) {
#ifdef USE_INTERSECT_CRUDE
    intersect_crude(scene, ray, hit);
#else
    bvh_intersect_iterative(bvh, scene, ray, hit);
#endif
}

// generated by gpt may not work
static PLATFORM Vec3 sample_triangle_uniform(rand_state_t &rstate, const Vec3 &a, const Vec3 &b,
                                             const Vec3 &c) {
    float u1, u2;
    do {
        u1 = random_uniform(rstate);
        u2 = random_uniform(rstate);
    } while (u1 + u2 > 1);
    return a + u1 * (b - a) + u2 * (c - a);
}

// static PLATFORM float
// area_of_triangle(const Vec3& a, const Vec3& b, const Vec3& c) {
//     Vec3 n = (c - b).cross(a - b);
//     return 0.5 * n.magnitude();
// }

struct area_light_sample_t {
    float p_als; // other fields are valid if p_als > 0
    Vec3 normal, dir_hit_to_light;
    float distance, area;
};
static PLATFORM void sample_area_light(area_light_sample_t &out, context_t &c,
                                       const Vec3 &shadow_pos, const Vec3 &shadow_normal,
                                       int face_index, bool direction_given) {
    const face_t &face = c.scene->faces[face_index];
    const material_t &mat = c.scene->materials[face.material];
    assert(face.vertexCount == 3);

    const Vec3 &A = c.scene->vertices[face.vertices[0]].position;
    const Vec3 &B = c.scene->vertices[face.vertices[1]].position;
    const Vec3 &C = c.scene->vertices[face.vertices[2]].position;

    Vec3 tri_cross = (C - B).cross(A - B);
    float tri_cross_length = tri_cross.magnitude();
    out.normal = tri_cross / tri_cross_length;
    out.area = 0.5 * tri_cross_length;

    if (!direction_given) {
        Vec3 light_pos = sample_triangle_uniform(c.rstate, A, B, C);
        out.dir_hit_to_light = (light_pos - shadow_pos).normalized();
    }

    Ray shadow_ray;
    initialize_safe_ray(shadow_ray, shadow_pos, out.dir_hit_to_light, shadow_normal);

    // check visibility
    intersection_t light_hit;
    intersect(c.bvh, c.scene, shadow_ray, light_hit);

    bool visible =
        light_hit.has_hit && light_hit.distance > 0 && light_hit.faceIndex == face_index;
    if (!visible) {
        out.p_als = 0;
        return;
    }

    // ????
    // // check if light points towards face
    // intersection_t pdf_hit;
    // intersect_face(c.scene, shadow_ray, pdf_hit, face_index);

    out.distance = light_hit.distance;
    float cos_theta_y = std::abs(out.normal.dot(out.dir_hit_to_light));
    out.p_als = out.distance * out.distance / (out.area * cos_theta_y);
}

struct light_source_sample_t {
    Vec3 incoming_radiance;
    Vec3 dir_hit_to_light;
    float p_lss;
    // Vec3 Ld;
    // float p_direct;
    // bool visible;
    // bsdf_sample_t light_dir_bsdf;
};

static PLATFORM void sample_light_source(light_source_sample_t &out, context_t &c,
                                         const Ray &ray, const intersection_t &hit) {
    if (c.lst->nodes.count == 0) {
        out.p_lss = 0;
        return;
    }

    // pick light node uniformly random
    int node_index = (int)(c.lst->nodes.count * random_uniform(c.rstate));
    const lst_node_t &node = c.lst->nodes[node_index % c.lst->nodes.count];

    out.p_lss = 1.0f / (float)c.lst->nodes.count;

    if (node.type == LST_SOURCE_LIGHT) {
        const light_t &light = c.scene->lights[node.index];

        if (light.type == LIGHT_POINT) {
            // TODO check maths to add radius
            // float light_rad = 0.1;
            Vec3 light_pos = light.position;
            // + light_rad * sphere_sample_uniform(c.rstate);

            Vec3 dir_hit_to_light = light_pos - hit.position;
            float distance = dir_hit_to_light.magnitude();
            out.dir_hit_to_light = dir_hit_to_light / distance;

            Ray shadow_ray;
            initialize_safe_ray(shadow_ray, hit.position, out.dir_hit_to_light,
                                hit.true_normal);

            intersection_t light_hit;
            intersect(c.bvh, c.scene, shadow_ray, light_hit);
            bool visible = distance < light_hit.distance;
            if (!visible) {
                out.p_lss = 0;
                return;
            }

            // https: //
            // github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md
            // https://physics.stackexchange.com/questions/382755/converting-illumination-to-irradiance#383501
            // this is only approximation, color spaces are violated
            float watts_per_lumen = 1.0 / 683.0;
            float radiant_intensity = light.intensity * watts_per_lumen;
            Vec3 light_radiance = light.color * radiant_intensity / (distance * distance);

            out.incoming_radiance = light_radiance;
            out.p_lss *= 1;
            return;

        } else {
            // directional light: TODO

            out.dir_hit_to_light = -light.direction;
            out.dir_hit_to_light.normalize();

            Ray shadow_ray;
            initialize_safe_ray(shadow_ray, hit.position, out.dir_hit_to_light,
                                hit.incident_normal);
            intersection_t shadow_hit;
            intersect(c.bvh, c.scene, shadow_ray, shadow_hit);
            if (shadow_hit.has_hit) {
                // not sun ray
                out.p_lss = 0;
                return;
            }

            float watts_per_lumen = 1.0 / 683.0;
            float radiance = light.intensity * watts_per_lumen;

            out.incoming_radiance = light.color * radiance;
            out.p_lss *= 1;
            return;
        }

    } else {
        // emitting face:

        area_light_sample_t als;
        sample_area_light(als, c, hit.position, hit.true_normal, node.index, false);

        out.dir_hit_to_light = als.dir_hit_to_light;

        const face_t &face = c.scene->faces[node.index];
        const material_t &mat = c.scene->materials[face.material];
        Vec3 radiosity = mat.emissive;

        out.incoming_radiance = radiosity; // TODO is this correct ???
        out.p_lss *= als.p_als;
        return;
    }
}

static PLATFORM float evaluate_direct_p(context_t &c, const Ray &ray,
                                        const intersection_t &hit) {

    uint32_t num_nodes = c.lst->nodes.count;
    if (num_nodes == 0) {
        return 0;
    }

    float p_total = 0;

    for (int i = 0; i < num_nodes; i++) {
        float p_node;

        const lst_node_t &node = c.lst->nodes[i];

        if (node.type == LST_SOURCE_LIGHT) {
            // at the moment, all light sources are dirac-delta, thus direct_p is 0 for non
            // light-sampled rays
            p_node = 0;

        } else {
            // face
            area_light_sample_t la;
            la.dir_hit_to_light = ray.r;
            sample_area_light(la, c, hit.position, hit.true_normal, node.index, true);
            p_node = la.p_als;
        }

        p_total += p_node;
    }

    p_total /= (float)num_nodes;
    return p_total;
}

#define RR_PROB_MAX 0.99

static PLATFORM Vec3 integrate_Li(context_t &c, Ray ray) {
    Vec3 light = {0, 0, 0};
    Vec3 throughput = {1, 1, 1};

    for (int depth = 0;; depth++) {
        intersection_t hit;
        intersect(c.bvh, c.scene, ray, hit);
        if (!hit.has_hit) {
            light += throughput * c.cfg.world_clear_color;
            break;
        }

        // EMISSIVE LIGHT
        Vec3 Le = hit.mat->emissive * throughput;
        light += Le;

        float rr_prob = fminf(throughput.maxComponent(), RR_PROB_MAX);
        if (random_uniform(c.rstate) >= rr_prob) {
            break; // ray dies
        }

        // DIRECT LIGHT
        light_source_sample_t lss;
        sample_light_source(lss, c, ray, hit);

        if (lss.p_lss > 0) {

            bsdf_sample_t lss_bsdf;
            evaluate_bsdf(lss_bsdf, ray.r, lss.dir_hit_to_light, hit, c.rstate);

            float cos_theta_x = std::abs(hit.true_normal.dot(lss.dir_hit_to_light));
            Vec3 direct_outgoing_radiance = lss_bsdf.bsdf * lss.incoming_radiance * cos_theta_x;

            // balance heuristic on part of direct light
            float weight = lss.p_lss / (lss.p_lss + lss_bsdf.prob_i);
            // printf("%.2f, %.2f\n", lss.p_direct, lss.light_dir_bsdf.prob_i);
            light += (weight / lss.p_lss) * throughput * direct_outgoing_radiance;
        }

        // INDIRECT LIGHT
        bsdf_sample_t indirect_bsdf;
        sample_bsdf(indirect_bsdf, ray.r, hit, c.rstate);
        assert(indirect_bsdf.prob_i > 0 && "sample with 0 probability");

        // set next ray
        initialize_safe_ray(ray, hit.position, indirect_bsdf.omega_i, hit.true_normal);
        float p_direct = evaluate_direct_p(c, ray, hit);
        float weight = indirect_bsdf.prob_i / (p_direct + indirect_bsdf.prob_i);

        float cos_theta = std::abs(hit.true_normal.dot(indirect_bsdf.omega_i));
        // find next throughput
        throughput *=
            indirect_bsdf.bsdf * (weight * cos_theta / (indirect_bsdf.prob_i * rr_prob));
    }

    CHECK_VEC(light);

    return light;
}

#ifdef USE_CPU_RENDER

__host__ void render_host(Vec3 *img, const __restrict__ bvh_t *bvh,
                          const __restrict__ obj_scene_data *scene, int pixel_x, int pixel_y,
                          settings_t settings, int previous_samples) {
    uint64_t tid = pixel_y * settings.width + pixel_x;

    rand_state_t rstate;
    random_init(rstate, settings.seed, tid);

    Vec3 total_light = {0, 0, 0};

    for (int i = 0; i < settings.samples; i++) {
        // float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x; /* TODO sensor variance */
        float sensor_y = (float)pixel_y; /* TODO sensor variance */

        float u = (2 * sensor_x - settings.width) / (float)settings.height;
        float v = (2 * sensor_y - settings.height) / (float)settings.height;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v, settings);

        Vec3 current_light = integrate_Li_iterative(bvh, scene, camera_ray, rstate);
        total_light += current_light;
    }

    total_light /= (float)settings.samples_per_round;

    int total_samples = settings.samples_per_round + previous_samples;
    Vec3 &pixel = img[pixel_y * settings.width + pixel_x];

    pixel = pixel * (previous_samples / (float)total_samples) +
            total_light * (settings.samples_per_round / (float)total_samples);
}

#else

// static PLATFORM Vec3
// sphere_sample_uniform(rand_state_t& rstate) {
//     Vec3 r;
//     do {
//         r.x = 2 * random_uniform(rstate) - 1;
//         r.y = 2 * random_uniform(rstate) - 1;
//         r.z = 2 * random_uniform(rstate) - 1;
//     } while (r.dot(r) > 1);

//     return r.normalized();
// }

// static PLATFORM void
// sanity_check(context_t& c) {

//     float a = 3;
//     Vec3 p;
//     p.x = 2 * a * random_uniform(c.rstate) - a;
//     p.y = 2 * a * random_uniform(c.rstate) - a;
//     p.z = 2 * a * random_uniform(c.rstate) - a;

//     intersection_t test_hit = {
//         has_hit: true,
//         distance: 0,
//         position: p,
//         lightingNormal: Vec3(1, 0, 0),
//         trueNormal: Vec3(1, 0, 0),
//         faceIndex: -1,
//         mat: nullptr,
//     };

//     int N = 100000;
//     float prob = 0;

//     for (int i = 0; i < N; i++) {

//         Vec3 r = sphere_sample_uniform(c.rstate);

//         Ray ray = { o: p, r: r };

//         prob += evaluate_direct_p(c, ray, test_hit);
//     }

//     printf("sum of p = %f\n", 4 * 3.1415 * prob / N);
// }

__global__ void render_kernel(Vec3 *img, const __restrict__ bvh_t *bvh,
                              const __restrict__ scene_t *scene, const __restrict__ lst_t *lst,
                              config_t cfg, int previousSamples, int currentSamples) {
    int pixel_x = threadIdx.x + blockDim.x * blockIdx.x;
    int pixel_y = threadIdx.y + blockDim.y * blockIdx.y;

    if (pixel_x >= cfg.resolution_x || pixel_y >= cfg.resolution_y) {
        return; // out of image
    }

    uint64_t curand_tid = pixel_y * cfg.resolution_x + pixel_x;

    context_t c(scene, bvh, lst, cfg);

    random_init(c.rstate, cfg.seed, curand_tid);

    Vec3 total_light = {0, 0, 0};

    for (int i = 0; i < currentSamples; i++) {
        float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x + sensor_variance * random_normal(c.rstate);
        float sensor_y = (float)pixel_y + sensor_variance * random_normal(c.rstate);

        float u = (2 * sensor_x - cfg.resolution_x) / (float)cfg.resolution_y;
        float v = (2 * sensor_y - cfg.resolution_y) / (float)cfg.resolution_y;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v);

        // intersection_t hit;
        // intersect(c.bvh, c.scene, camera_ray, hit);
        // Vec3 current_light;
        // if (hit.has_hit) {
        //     current_light = {1, 1, 1};
        // } else {
        //     current_light = {0, 0, 0};
        // }

        Vec3 current_light = integrate_Li(c, camera_ray);

        // Vec3 current_light = integrate_Li_classic(bvh, scene, lst, camera_ray, rstate,
        // settings);

        total_light += current_light;
    }

    total_light *= 2; // test exposure

    total_light /= (float)currentSamples;

    int total_samples = previousSamples + currentSamples;
    Vec3 last_pixel = img[pixel_y * cfg.resolution_x + pixel_x];

    Vec3 next_pixel = last_pixel * (previousSamples / (float)total_samples) +
                      total_light * (currentSamples / (float)total_samples);

    img[pixel_y * cfg.resolution_x + pixel_x] = next_pixel;
}

#endif
