#include <assert.h>
#include <stdio.h>
#include <time.h>

#include <iostream>

#include "bsdf.h"
#include "config.h"
#include "lst.h"
#include "mathops.h"
#include "random.h"
#include "renderer.h"
#include "scene.h"

static PLATFORM void
get_camera_ray(Ray& ray, const __restrict__ scene_t* scene,
               float u, float v, const settings_t& settings) {
    const Vec3& P = scene->camera.position;
    const Vec3& T = scene->camera.target;
    const Vec3& Up = scene->camera.updir;

    Vec3 W = T - P;
    Vec3 U = W.cross(Up);
    Vec3 V = U.cross(W);

    float focal_length = 0.1;  // doesn't really matter at this point
    float yheight = atanf(0.5 * scene->camera.yfov) * focal_length;

    U = U.normalized() * yheight;
    V = V.normalized() * yheight;
    W = W.normalized() * focal_length;

    // U, V, W build orthogonal basis for camera ray direction
    // D = u*U + v*V + 1*W
    // build change of basis matrix A
    Mat3 A(
        U.x, V.x, W.x,
        U.y, V.y, W.y,
        U.z, V.z, W.z);

    // camera coordinate vector for pixel
    Vec3 x = {u, v, 1};

    ray.o = P;
    ray.r = (A * x).normalized();
}

// offset new ray slightly from triangle in normal dir
#define SAVE_RAY_EPS 1e-6

static PLATFORM void
initialize_safe_ray(Ray& ray, const Vec3& origin, const Vec3& dir, const Vec3& normal) {
    bool transmit = dir.dot(normal) < 0;

    ray.o = origin + SAVE_RAY_EPS * (transmit ? -normal : normal);
    ray.r = dir;
}

static PLATFORM void
intersect(const __restrict__ bvh_t* bvh, const __restrict__ scene_t* scene,
          const Ray& ray, intersection_t& hit) {
    hit.has_hit = 0;
    hit.distance = CLEAR_DISTANCE;
#ifdef USE_INTERSECT_CRUDE
    intersect_crude(scene, ray, hit);
#else
    bvh_intersect_iterative(bvh, scene, ray, hit);
#endif
}

// generated by gpt may not work
static PLATFORM Vec3
sample_triangle_uniform(rand_state_t& rstate, const Vec3& a, const Vec3& b, const Vec3& c) {
    float u1, u2;
    do {
        u1 = random_uniform(rstate);
        u2 = random_uniform(rstate);
    } while (u1 + u2 > 1);
    return a + u1 * (b - a) + u2 * (c - a);
}

// static PLATFORM float
// area_of_triangle(const Vec3& a, const Vec3& b, const Vec3& c) {
//     Vec3 n = (c - b).cross(a - b);
//     return 0.5 * n.magnitude();
// }

static PLATFORM Vec3
integrate_Ld(const __restrict__ bvh_t* bvh,
             const __restrict__ scene_t* scene,
             const __restrict__ lst_t* lst,
             const Ray& ray, const intersection_t& hit, rand_state_t& rstate, settings_t& settings) {
    if (!lst->nodes.count) {
        return Vec3::Zero();
    }

    // pick light node uniformly randoms
    int nodeIndex = (int)(lst->nodes.count * random_uniform(rstate));
    const lst_node_t& node = lst->nodes[nodeIndex % lst->nodes.count];
    float p_inv = (float)lst->nodes.count;

    if (node.type == LST_SOURCE_LIGHT) {
        const light_t& light = scene->lights[0];

        if (light.type == LIGHT_POINT) {
            Vec3 light_dir = light.position - hit.position;
            float r = light_dir.magnitude();
            light_dir /= r;

            Ray light_ray;
            initialize_safe_ray(light_ray, hit.position, light_dir, hit.trueNormal);

            intersection_t light_hit;
            intersect(bvh, scene, light_ray, light_hit);
            bool visible = r < light_hit.distance;

            if (!visible) {
                return Vec3(0, 0, 0);
            }

            // diffuse
            Vec3 bsdf = evaluate_bsdf(ray.r, light_dir, hit, rstate);

            float cosThetaX = std::abs(hit.trueNormal.dot(light_dir));

            float radiantIntensity = light.intensity / 683.0;  // this is only approximation, color spaces are violated
            Vec3 integrand = light.color * radiantIntensity / (r * r);

            Vec3 Ld = bsdf * integrand * cosThetaX;  // *integrates* over point

            return Ld * p_inv;
        } else {
            assert(false);  // TODO directional
        }

    } else {
        // printf("face light\n");

        const face_t& face = scene->faces[node.index];
        const material_t& mat = scene->materials[face.material];
        assert(face.vertexCount == 3);

        const Vec3& A = scene->vertices[face.vertices[0]].position;
        const Vec3& B = scene->vertices[face.vertices[1]].position;
        const Vec3& C = scene->vertices[face.vertices[2]].position;

        // Vec3 light_pos = 0.3333 * (A + B + C);
        Vec3 light_pos = sample_triangle_uniform(rstate, A, B, C);

        Vec3 tri_cross = (C - B).cross(A - B);
        float tri_cross_length = tri_cross.magnitude();
        Vec3 tri_normal = tri_cross / tri_cross_length;
        float tri_area = 0.5 * tri_cross_length;

        p_inv *= tri_area;

        Vec3 light_dir = light_pos - hit.position;
        float r = light_dir.magnitude();
        light_dir /= r;

        Ray light_ray;
        initialize_safe_ray(light_ray, hit.position, light_dir, hit.trueNormal);

        intersection_t light_hit;
        intersect(bvh, scene, light_ray, light_hit);
        // printf("%.3f, %.3f\n", r, light_hit.distance);

        // bool visible = r - 3e-3f > light_hit.distance;
        bool visible = light_hit.faceIndex == node.index;
        if (!visible) {
            return Vec3(0, 0, 0);
        }

        // diffuse
        Vec3 bsdf = evaluate_bsdf(ray.r, light_dir, hit, rstate);

        float cosThetaX = std::abs(hit.trueNormal.dot(light_dir));
        float cosThetaY = std::abs(tri_normal.dot(light_dir));

        Vec3 radiosity = mat.emissive;  // assumes W/m^2
        Vec3 integrand = cosThetaY * radiosity / (r * r /* * 2 * M_PI */);

        Vec3 Ld = bsdf * integrand * cosThetaX;  // integrate light

        // Ld.print();

        return Ld * p_inv;
    }

    assert(false);  // ???
    return Vec3::Zero();
}

#define RR_PROB_MAX 0.99

static PLATFORM Vec3
integrate_Li(const __restrict__ bvh_t* bvh,
             const __restrict__ scene_t* scene,
             const __restrict__ lst_t* lst,
             Ray ray, rand_state_t& rstate, settings_t& settings) {
    Vec3 light = {0, 0, 0};
    Vec3 throughput = {1, 1, 1};

    for (int depth = 0;; depth++) {
        intersection_t hit;
        intersect(bvh, scene, ray, hit);
        if (!hit.has_hit) {
            light += throughput * settings.world.clear_color;
            break;
        }

        if (depth == 0) {
            // direct light, attenuate using throughput which includes indirect lighting penalty
            Vec3 Le = hit.mat->emissive * throughput;
            light += Le;
        }


        float rr_prob = fminf(throughput.maxComponent(), RR_PROB_MAX);
        if (random_uniform(rstate) >= rr_prob) {
            break;  // ray dies
        }

        light += throughput * integrate_Ld(bvh, scene, lst, ray, hit, rstate, settings);

        bsdf_sample_t bsdf;
        sample_bsdf(bsdf, ray.r, hit, rstate);
        assert(bsdf.prob_i != 0 && "sample with 0 probability");

        float cosTheta = std::abs(hit.trueNormal.dot(bsdf.omega_i));

        // set next ray
        initialize_safe_ray(ray, hit.position, bsdf.omega_i, hit.trueNormal);

        // find next throughput
        throughput *= bsdf.bsdf * (cosTheta / (bsdf.prob_i * rr_prob));
    }

    return light;
}

static PLATFORM Vec3
integrate_Li_classic(const __restrict__ bvh_t* bvh,
             const __restrict__ scene_t* scene,
             const __restrict__ lst_t* lst,
             Ray ray, rand_state_t& rstate, settings_t& settings) {
    Vec3 light = {0, 0, 0};
    Vec3 throughput = {1, 1, 1};

    for (int depth = 0;; depth++) {
        intersection_t hit;
        intersect(bvh, scene, ray, hit);
        if (!hit.has_hit) {
            light += throughput * settings.world.clear_color;
            break;
        }

        // direct light, attenuate using throughput which includes indirect lighting penalty
        Vec3 Le = hit.mat->emissive * throughput;
        light += Le;


        float rr_prob = fminf(throughput.maxComponent(), RR_PROB_MAX);
        if (random_uniform(rstate) >= rr_prob) {
            break;  // ray dies
        }

        // light += throughput * integrate_Ld(bvh, scene, lst, ray, hit, rstate, settings);

        bsdf_sample_t bsdf;
        sample_bsdf(bsdf, ray.r, hit, rstate);
        assert(bsdf.prob_i != 0 && "sample with 0 probability");

        float cosTheta = std::abs(hit.trueNormal.dot(bsdf.omega_i));

        // set next ray
        initialize_safe_ray(ray, hit.position, bsdf.omega_i, hit.trueNormal);

        // find next throughput
        throughput *= bsdf.bsdf * (cosTheta / (bsdf.prob_i * rr_prob));
    }

    return light;
}

#ifdef USE_CPU_RENDER

__host__ void
render_host(Vec3* img,
            const __restrict__ bvh_t* bvh, const __restrict__ obj_scene_data* scene,
            int pixel_x, int pixel_y,
            settings_t settings, int previous_samples) {
    uint64_t tid = pixel_y * settings.width + pixel_x;

    rand_state_t rstate;
    random_init(rstate, settings.seed, tid);

    Vec3 total_light = {0, 0, 0};

    for (int i = 0; i < settings.samples; i++) {
        // float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x; /* TODO sensor variance */
        float sensor_y = (float)pixel_y; /* TODO sensor variance */

        float u = (2 * sensor_x - settings.width) / (float)settings.height;
        float v = (2 * sensor_y - settings.height) / (float)settings.height;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v, settings);

        Vec3 current_light = integrate_Li_iterative(bvh, scene, camera_ray, rstate);
        total_light += current_light;
    }

    total_light /= (float)settings.samples_per_round;

    int total_samples = settings.samples_per_round + previous_samples;
    Vec3& pixel = img[pixel_y * settings.width + pixel_x];

    pixel = pixel * (previous_samples / (float)total_samples) + total_light * (settings.samples_per_round / (float)total_samples);
}

#else

__global__ void
render_kernel(Vec3* img,
              const __restrict__ bvh_t* bvh,
              const __restrict__ scene_t* scene,
              const __restrict__ lst_t* lst,
              settings_t settings, int previousSamples, int currentSamples) {
    int pixel_x = threadIdx.x + blockDim.x * blockIdx.x;
    int pixel_y = threadIdx.y + blockDim.y * blockIdx.y;

    if (pixel_x >= settings.output.width || pixel_y >= settings.output.height) {
        return;  // out of image
    }

    uint64_t curand_tid = pixel_y * settings.output.width + pixel_x;

    rand_state_t rstate;
    random_init(rstate, settings.sampling.seed, curand_tid);

    Vec3 total_light = {0, 0, 0};

    for (int i = 0; i < currentSamples; i++) {
        float sensor_variance = 0.33;
        float sensor_x = (float)pixel_x + sensor_variance * random_normal(rstate);
        float sensor_y = (float)pixel_y + sensor_variance * random_normal(rstate);

        float u = (2 * sensor_x - settings.output.width) / (float)settings.output.height;
        float v = (2 * sensor_y - settings.output.height) / (float)settings.output.height;

        Ray camera_ray;
        get_camera_ray(camera_ray, scene, u, v, settings);

        Vec3 current_light = integrate_Li(bvh, scene, lst, camera_ray, rstate, settings);

        // Vec3 current_light = integrate_Li_classic(bvh, scene, lst, camera_ray, rstate, settings);

        total_light += current_light;
    }

    total_light /= (float)currentSamples;

    int total_samples = previousSamples + currentSamples;
    Vec3 last_pixel = img[pixel_y * settings.output.width + pixel_x];

    Vec3 next_pixel = last_pixel * (previousSamples / (float)total_samples) + total_light * (currentSamples / (float)total_samples);

    img[pixel_y * settings.output.width + pixel_x] = next_pixel;
}

#endif